---
slug: learn-log-2
title: 学习日志-2
authors: bing
tags: [base64, promise]
---

今天的主要内容有： - 将图片文件转换成 ASCII 码形式的字符串 - 重新又学习了一下 promise

图片文件实际上就是一个二进制文件，里面存储的东西都是 0 和 1。base64 的定义是：一组将二进制数据转换成 ASCII 码字符串的编码模式。为什么说是一组呢，因为其中编码的算法有很多种，同一张图片，使用不同的算法，它们将会转换成不同的字符串。我举个例子，第一种算法将`00000000 -> %2`，第二种算法将`00000000 -> %3`。

`promise`是一种异步编程，以前看过几次，都是到懂不懂的，只是有个模糊的概念，今天又去回顾了一下，这次应该是听懂了，但是想要自己手写`Promise`类还是有点难度，我打算明天就自己尝试手写一下，能手写出来我就是真的懂了。

{/* truncate */}

## FileReader

`FileReader`是 js 原生的一个类，首先来讲一讲它的实例一些东西（当然我只会讲我用到的）：

**属性**

- `readyState` ：

  - EMPTY ：实例还未加载数据
  - LOADING ：正在加载数据
  - DONE ： 加载完成

- result ： 当加载完成时，它会有效，它就是最终的结果

**方法**

- `readAsDataURL()` ：参数是一个二进制文件，调用这个方法就会开始将二进制文件转换 ASCII 码的格式，结果保存在`result`中

**事件**

- `load` ：当加载完毕，并且成功的时候触发
- `loadend` ：当加载完毕时就会触发，不管成功与否

最后就是使用的时候，关于`I/O`，也就是关于数据的输入输出，大多数的方法都是异步（可能有些不是，我也不太清楚），因为这样就不会阻塞整个程序的运行。

一般的使用方法就是监听`FileReader`实例的`load`事件，然后调用相关实例的方法，最后在`load`事件的响应函数中通过`result`获取结果

:::danger
类名都是大写开头的，今天竟然能写出`new fileReader()`这种十年脑血栓代码，还有就是一个`FileReader`实例一次只能读取一个文件，所以当读取多个文件时，对于每个文件都要创建一个`FileReader`实例，并且为它绑定`load`事件
:::

今天还犯了一个愚蠢的错误，它是关于`dom`的，我混淆了`element.remove()`和`element.removeChild()`，前者是移除自身，后者是移除子元素（参数是一个子元素）

## promise

**同步和异步**

在讲这个的时候先说一些基本概念，进程相当于一个工厂，饭店之类的，里面有生产东西的资源，而线程相当于工人，它是干活的。同步和异步我来举个例子：你去一个饭店吃饭，然后一个服务员来招待你，这个服务员就相当于一个线程，然后你给他说你要的菜品，他就会给厨师说要做这个菜，厨师就相当于数据库，做菜就相当于给你找相关的数据，如果你就傻等的菜啥也不干，这就相当于是同步，你要做完一件事才能去做其他的事，当前的任务就是吃饭，但是菜还没有做好，你就要等，但是在现实中，我们一般都不会傻等着，我们会找个地方坐着玩手机，这就是异步的，等菜做好了，我们在直接吃，中间等待的时间就可以去做其他的事。

:::info
`javascript`是单线程的，不使用异步的话，用户将会增加很多等待的时间，这有损于用户体验。
:::

**怎么实现异步呢**

实现异步有很多种方式，比如`setTimeout()`定时器函数，`promise`，定义`asnyc`函数等，一下是一个简单的异步代码：

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

<Tabs>
    <TabItem value="js" label="js">

```js title="example.js" showLineNumbers
setTimeout(() => {
  console.log(1);
}, 1000);

console.log(2);
```

    </TabItem>
    <TabItem value="resulst" label="result">

```bash
2
1
```

    </TabItem>

</Tabs>

现在可以对于没有接触过异步的人觉得匪夷所思，按照同步的思维，代码都是至顶向下执行的，这个`setTimeout()`不是在前面吗，为什么不是先打印`1`，而是`2`呢。

:::note
并不是跟定时器函数的第二个参数延迟有关，就算延迟设置为`0`，也是同样的结果，接下来我会讲到调用栈，宏队列和微队列，讲完你就会明白
:::

全局作用域的代码直接在调用栈中，还是说上面的那个例子，在调用栈的代码就是`setTimeout()`和`console.log(2)`，好，现在开始执行，因为`setTimeout()`是异步的，它执行的结果是将它的回调函数`console.log(1)`在`1000`毫秒后放进宏队列中进行排队，然后在执行`console.log(2)`，这时控制台就会输出`2`，在队列中排队的代码会在调用栈为空的时候，依次进入调用栈进行执行。此时因为调用栈为空，在宏队列中的`console.log(1)`就会进入调用栈中执行。

这里还有一个队列，它叫做微队列，它相当于是 vip 队列，当调用栈为空时，在这个队列中排队的代码会优先于宏队列的代码先进入调用栈中执行，`promise`里面的异步代码就会进入微队列中

现在有一个非常重要的问题，我们要怎么从异步代码中获取返回值呢。下列代码想获取`setTimeout()`中的`result`

```js title="example-2.js" showLineNumbers
setTimeout(() => {
  const result = 1 + 1;
}, 1000);

console.log(result);
```

这样的输出结果只能是`undefined`，因为刚刚讲了下面的`console.log()`语句会先执行，其实也不是这个问题，是作用域的问题，那么很多人就会说了，写成这个样子就行了：

```js title="example-3.js" showLineNumbers
const result = setTimeout(() => {
  return 1 + 1;
}, 1000);

console.log(result);
```

然而这样也不行，那个`return`的返回值是那个箭头函数的，不是`setTimeout()`的。那么我们怎么样才能获取到那个`1 + 1`表达式的值呢，最常规的办法就是回调函数。给箭头函数传递一个回调函数，然后将箭头函数的结果作为这个回调函数的参数，像下面这样：

```js title="example-4.js" showLineNumbers
const result = setTimeout((getResult) => {
  getResult(1 + 1);
}, 1000);

function getResult(result) {
  console.log(result);
}
```

额，今天时间好像不够了，promise 都还没有讲，只能说留给明天了，正好我明天还会更加深入了解 promise，明天写可能效果会好点。我现在已经感觉到写静态代码块的无力感了，它不能互动，不能输入你写的代码的结果，这使我的解释有点僵硬，这也催使我要去学习那个`live code blocks`，这个代码块可以被编辑的，还可以输出结果，相当于一个在线编辑器加一个运行环境。
